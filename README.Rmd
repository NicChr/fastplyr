---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  cache = TRUE
)
```

# fastplyr

<!-- badges: start -->

[![R-CMD-check](https://github.com/NicChr/fastplyr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/NicChr/fastplyr/actions/workflows/R-CMD-check.yaml)

<!-- badges: end -->

fastplyr aims to provide a [tidyverse](https://www.tidyverse.org/learn) frontend using a [collapse](https://sebkrantz.github.io/collapse/articles/collapse_intro.html) backend. This means from a user's point of view the functions behave like the tidyverse equivalents and thus require little to no changes to existing code to convert.

fastplyr is designed to handle operations that involve larger numbers of groups and generally larger data.

## Installation

You can install the development version of fastplyr from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("NicChr/fastplyr")
```

Load packages

```{r example}
library(tidyverse)
library(fastplyr)
library(nycflights13)
library(bench)
```

While the syntax and user-interface of fastplyr aligns very closely with dplyr most of the time, there can be a few key differences.

## Differences between fastplyr and dplyr

+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
|                          | ### dplyr                                                                                                        | ### fastplyr                                                                                                              |
+==========================+==================================================================================================================+===========================================================================================================================+
| `.by`                    | Groups are sorted by order of first appearance always when using `.by`                                           | Groups are always sorted by default, even when using `.by`. One can use the other sorting through `f_group_by(order = F)` |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Many groups              | Generally slow for data with many groups.                                                                        | Designed to be fast for data with many groups.                                                                            |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Handling of dots (`...`) | dplyr almost always executes `...` expressions in a way that latter expressions depend on previous ones          | Some functions like `f_summarise` and `f_expand` execute the expressions in `...` independently.                          |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Duplicate rows           | No dedicated function for this, solution using `group_by |> filter(n() > 1)` are generally slow for larger data. | Dedicated function `f_duplicates` can do this very fast and with fine control.                                            |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Unique group IDs         | Achieved through `mutate(cur_group_id())`                                                                        | Dedicated fast function `add_group_id()`                                                                                  |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Row slicing              | `slice()` supports data-masked expressions supplied to `...`                                                     | Data-masked expressions not supported in `f_slice_` functions. Use `f_filter()` for this behaviour.                       |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Memory usage             | High memory usage                                                                                                | Lower usage compared to dplyr                                                                                             |
+--------------------------+------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+

## dplyr alternatives

All tidyverse alternative functions are prefixed with 'f\_'. For example, `dplyr::distinct` becomes `fastplyr::f_distinct`.

### distinct

```{r}
flights |> 
  f_distinct(origin, dest)
```

`f_distinct` has an additional `sort` argument which is much faster than sorting afterwards.

```{r}
mark(
  fastplyr_distinct_sort = flights |> 
  f_distinct(origin, dest, tailnum, sort = TRUE),
  dplyr_distinct_sort = flights |> 
    distinct(origin, dest, tailnum) |> 
    arrange_all()
)
```

### group_by

`f_group_by` operates very similarly with an additional feature that allows you to specify whether group data should be ordered or not. This ultimately controls if the groups end up sorted in expressions like `count` and `summarise`, but also in this case `f_count` and `f_summarise`.

```{r}
# Like dplyr
flights |> 
  f_group_by(month) |> 
  f_count()

# Group data is sorted by order-of-first appearance
flights |> 
  f_group_by(month, order = FALSE) |> 
  f_count()
```

Just a reminder that all fastplyr functions are interchangeable with dplyr ones both ways

```{r}

### With dplyr::count

flights |> 
  f_group_by(month) |> 
  count()
```

```{r}

### With dplyr::group_by

flights |> 
  group_by(month) |> 
  f_count()
```

### summarise

`f_summarise` behaves like dplyr's `summarise` except for two things:

-   It evaluates expressions independently
-   There are optimisations for common statistical functions which are very fast for many groups

```{r}
grouped_flights <- flights |> 
  group_by(across(where(is.character)))

grouped_flights |> 
  f_summarise(
    n = n(), mean_dep_delay = mean(dep_delay)
  )
```

And a benchmark

```{r}
mark(
  fastplyr_summarise = grouped_flights |> 
  f_summarise(
    n = n(), mean_dep_delay = mean(dep_delay)
  ),
  dplyr_summarise = grouped_flights |> 
  summarise(
    n = n(), mean_dep_delay = mean(dep_delay, na.rm = TRUE),
    .groups = "drop"
  )
)
```

### slice

`f_slice` and other `f_slice_` functions are very fast for many groups.

```{r}
grouped_flights |> 
  f_slice(1)

grouped_flights |>
  f_slice_head(3)
```

A quick benchmark to prove the point

```{r}
mark(
    fastplyr_slice = grouped_flights |> 
    f_slice_head(n = 3),
    dplyr_slice = grouped_flights |>
        slice_head(n = 3)
)
```

### Group IDs

In dplyr to work with group IDs you must use the `mutate()` + `cur_group_id()` paradigm.

In fastplyr you can just use `add_group_id()` which is blazing fast.

```{r}

## Unique ID for each group

grouped_flights |> 
  add_group_id() |> 
  f_select(group_id)

```

Another benchmark

```{r}
mark(
  fastplyr_group_id = grouped_flights |> 
  add_group_id() |> 
  f_select(group_id),
  dplyr_group_id = grouped_flights |> 
  mutate(group_id = cur_group_id()) |> 
  select(group_id)
)
```


### expand

Based closely on `tidyr::expand`, `f_expand()` can cross joins multiple vectors and data frames.

```{r}
mark(
  fastplyr_expand = grouped_flights |> 
  f_expand(month = 1:12),
  tidyr_expand = grouped_flights |> 
  expand(month = 1:12),
  check = FALSE
)
```

### duplicate rows

Finding duplicate rows is a very common dataset operation and there is a 
dedicated function `f_duplicates()` to do exactly this.

```{r}
flights |> 
  f_duplicates(time_hour)
```

Benchmark against a common dplyr stratefy for finding duplicates

```{r}
mark(
 fastplyr_duplicates = flights |> 
   f_duplicates(time_hour, .both_ways = TRUE, .add_count = TRUE, .keep_all = TRUE),
 dplyr_duplicates = flights |> 
   add_count(time_hour) |> 
   filter(n > 1)
)
```



