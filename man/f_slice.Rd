% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/f_slice.R
\name{f_slice}
\alias{f_slice}
\alias{f_slice_head}
\alias{f_slice_tail}
\alias{f_slice_min}
\alias{f_slice_max}
\alias{f_slice_sample}
\title{Faster \code{dplyr::slice()}}
\usage{
f_slice(data, i, .by = NULL, keep_order = FALSE)

f_slice_head(data, n, prop, .by = NULL, keep_order = FALSE)

f_slice_tail(data, n, prop, .by = NULL, keep_order = FALSE)

f_slice_min(
  data,
  order_by,
  n,
  prop,
  .by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  keep_order = FALSE
)

f_slice_max(
  data,
  order_by,
  n,
  prop,
  .by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  keep_order = FALSE
)

f_slice_sample(
  data,
  n,
  replace = FALSE,
  prop,
  .by = NULL,
  keep_order = FALSE,
  weights = NULL,
  seed = NULL
)
}
\arguments{
\item{data}{Data frame}

\item{i}{An \link{integer} vector of slice locations. \cr
Expressions that refer to variables in the data will not work by group.
For example \code{f_slice(data, which(x == max(y)), .by = g)} will not work properly
but \code{f_slice(data, sample(1:10), .by = g)} will. \cr
This is for speed purposes because expressions can usually be supplied through
\code{f_filter()} which does accept the former type of expression.}

\item{.by}{(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.}

\item{keep_order}{Should the sliced data frame be returned in its original order?
The default is \code{FALSE}.}

\item{n}{Number of rows.}

\item{prop}{Proportion of rows.}

\item{order_by}{Variables to order by.}

\item{with_ties}{Should ties be kept together? The default is \code{TRUE}.}

\item{na_rm}{Should missing values in \code{f_slice_max()} and \code{f_slice_min()} be removed?
The default is \code{FALSE}.}

\item{replace}{Should \code{f_slice_sample()} sample with or without replacement?
Default is \code{FALSE}, without replacement.}

\item{weights}{Probability weights used in \code{f_slice_sample()}.}

\item{seed}{Seed number defining RNG state.
If supplied, this is only applied \bold{locally} within the function
and the seed state isn't retained after sampling.
To clarify, whatever seed state was in place before the function call,
is restored to ensure seed continuity.
If left \code{NULL} (the default), then the seed is never modified.}
}
\value{
A \code{data.frame} of specified rows.
}
\description{
When there are lots of groups, the \code{f_slice()} functions are much faster.
}
\details{
\code{f_slice()} and friends allow for more flexibility in how you order the by-group slicing. \cr
Furthermore, you can control whether the returned data frame is sliced in
the order of the supplied row indices, or whether the
original order is retained (like \code{dplyr::filter()}).

In \code{f_slice()}, when \code{length(n) == 1}, an optimised method is implemented
that internally uses \code{list_subset()}, a fast function for extracting
single elements from single-level lists that contain vectors of the same
type, e.g. integer.

\code{f_slice_head()} and \code{f_slice_tail()} are very fast with large numbers of groups.

\code{f_slice_sample()} is arguably more intuitive as it by default
resamples each entire group without replacement, without having to specify a
maximum group size like in \code{dplyr::slice_sample()}.
}
